/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  2312                                  |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    arch        "LSB;label=32;scalar=64";
    class       volScalarField;
    location    "0";
    object      ID;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

dimensions      [0 0 0 0 0 0 0];

internalField #codeStream
{
        codeInclude
        #{
                #include "fvCFD.H"
                #include "Ostream.H"
        #};

        codeOptions
        #{
                -I$(LIB_SRC)/finiteVolume/lnInclude \
                -I$(LIB_SRC)/meshTools/lnInclude
        #};

        codeLibs
        #{
                -lmeshTools \
                -lfiniteVolume
        #};

        code
        #{

		const IOdictionary& d = static_cast<const IOdictionary&>(dict);
		const fvMesh& mesh = refCast<const fvMesh>(d.db());
		//First tumor
		scalarField ID(mesh.nCells(), 0.);
		scalar raiot = 0.005;
		scalar ee = 0.9;
		scalar be = raiot*pow((1-pow(ee,2)),0.25);
		scalar ae = pow(pow(be,2)*(pow(1-pow(ee,2),-1)),0.5);
		scalar he = 0.045-5*ae;
		scalar ke = 0.045;
		//Second tumor
		scalar raiot2 = 0.005;
		scalar ee2 = 0.9;
		scalar be2 = raiot*pow((1-pow(ee,2)),0.25);
		scalar ae2 = pow(pow(be,2)*(pow(1-pow(ee,2),-1)),0.5);
		scalar he2 = 0.045+5*ae2;
		scalar ke2 = 0.045;
		
		
		
		forAll(ID, i)
                {
                        const scalar x = mesh.C()[i][0];
			const scalar y = mesh.C()[i][1];
			const scalar z = mesh.C()[i][2];
//		        const scalar y = mesh.C() [i][1];
//            		const scalar z = mesh.C() [i][2];

			// constant-gradient applied field
			if ( pow(y-ke,2) <= ((1 - pow(x-he,2)/pow(ae,2) )*pow(be,2)) )
			{
			ID[i] = 1.;
			}
			
			if ( pow(y-ke2,2) <= ((1 - pow(x-he2,2)/pow(ae2,2) )*pow(be2,2)) )
			{
			ID[i] = 1.;
			}
			

                }
                ID.writeEntry("", os);

        #};
};


boundaryField
{
    leftWall
    {
        type            fixedValue;
        value           uniform 0;
    }
    rightWall
    {
        type            fixedValue;
        value           uniform 0;
    }
    lowerWall
    {
        type            fixedValue;
        value           uniform 0;
    }
    upperWall
    {
        type            fixedValue;
        value           uniform 0;
    }
    defaultFaces
    {
        type            empty;
    }
}


// ************************************************************************* //
